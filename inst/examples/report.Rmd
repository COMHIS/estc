---
title: "Overview of a list of ESTC entries `r params$min.year`-`r params$max.year`"
subtitle: "`r params$subtitle`"
author: "Mikko Tolonen, Leo Lahti, Eetu Makela et al."
date: "`r Sys.Date()`"
fontsize: 13pt
geometry: margin=1in
linkcolor: magenta
urlcolor: blue
citecolor: black
institute: "University of Helsinki & University of Turku"
output: 
  beamer_presentation:
    theme: "boxes"
    colortheme: "orchid"
    fonttheme: "professionalfonts"
  pdf_document:
    fig_width: 7
    fig_height: 6
    fig_caption: true
    includes:
      in_header: header.tex
params:
  min.year: 
    label: "Start year:"
    input: numeric
    value: 1470
  max.year: 
    label: "End year:"
    input: numeric
    value: 1880
  date: 
    label: "Date:"
    value: !r date()
    input: date
  subtitle: 
    label: "Subtitle:"
    value: My subtitle
    input: text
  idsource: 
    label: "Document IDs:"
    value: history_of_england_headings.txt
    input: text
---

```{r init, echo=FALSE, message=FALSE, warning=FALSE, echo=FALSE, cache=FALSE}
# For all parameter options for rmarkdown slide rendering, see:
# http://rmarkdown.rstudio.com/developer_parameterized_reports.html
# More header options in Pandoc manual
# http://pandoc.org/MANUAL.html#templates

#library(devtools)
#library(bibliographica)
#install_github("ropengov/bibliographica")

# Read parameters from the header
mydate <- params$start
min.year <- params$min.year
max.year <- params$max.year

library(estc)
library(magrittr)
library(sorvi)
library(reshape2)
library(gridExtra)
library(knitr)
library(ggmap)
library(stringr)
library(dplyr)
library(tidyr)
library(reshape2)
library(ggplot2)
library(bibliographica)
library(sorvi)
library(devtools)
knitr::opts_chunk$set(echo = FALSE)
#knitr::opts_chunk$set(fig.path = "figure_slides/", dev="CairoPNG")
knitr::opts_chunk$set(fig.path = "figure_slides/")

# Set locale
# tmp <- Sys.setlocale(locale="UTF-8") 

# Nice theme
theme_set(theme_bw(26))

# Nice default themes
# https://github.com/cttobin/ggthemr#palettes
#ggthemr('fresh', text_size = 20)
# ggthemr('greyscale', text_size = 20)
#ggthemr('light', text_size = 20)
# ggthemr('pale', text_size = 20)
#ggthemr_reset() # Reset theme

# Default number of top hits to show
ntop <- 20
```


```{r data, echo=FALSE, message=FALSE, warning=FALSE, echo=FALSE, cache=FALSE}
# Read the preprocessed data
df.preprocessed <- readRDS("df.Rds")

# Metadata field for the IDs
#idfield <- "control_number"
idfield <- "system_control_number"

# Read the custom list of entry IDs
# Including also the number of hits per document
# and document total length for normalization purposes
idfile <- params$idsource
#ids0 <- as.character(unlist(read.csv(idfile), use.names = FALSE))
custom.ids <- read.table(idfile, skip = 1)[, c(1, 2, 4)]
ids.orig <- as.character(custom.ids[,1])
custom.ids[,1] <- gsub("\\,$", "", as.character(custom.ids[,1]))
custom.ids[,2] <- as.numeric(as.character(custom.ids[,2]))
custom.ids[,3] <- as.numeric(as.character(custom.ids[,3]))
names(custom.ids) <- c("id", "freq", "length")
#ids0 <- as.character(unlist(read.csv(idfile), use.names = FALSE))

# Add normalization field: hits per 1000 words
custom.ids$freq.normalized <- 1e3 * custom.ids$freq/custom.ids$length

# Remove leading zeroes from the IDs to get them
# compatible with our versions
custom.ids$id <- apply(cbind(substr(custom.ids$id, 1, 1), gsub("^[A-Z]0*", "", custom.ids$id)), 1, function (x) {paste(x, collapse = "")})
#rownames(custom.ids) <- custom.ids$id

# Custom subsetting by years
df0 <- df.preprocessed

# Pick entries with the given IDs
# .. must remove the source ID from the ESTC strings
df0$id <- sapply(strsplit(as.character(df0[, idfield]), ")"), function (xi) {xi[[length(xi)]]})
df0 <- df0[df0$id %in% custom.ids$id,]

# Not found
notfound <- setdiff(custom.ids$id, df0$id)

# Number and percentage of the custom list IDs that were found
hitn0 <- sum(custom.ids$id %in% df0$id, na.rm = TRUE)
hitp0 <- 100 * hitn0/nrow(custom.ids)

df0 <- df0 %>% filter(publication_year >= min.year &
			                publication_year <= max.year)

# Hits after subsetting
hitn1 <- nrow(df0)
hitp1 <- 100 * hitn1/nrow(custom.ids)
```

### Technical notes

Entry IDs (n=`r nrow(custom.ids)`) are read from the file:  `r params$idsource`

Custom identifiers found from complete ESTC: n=`r hitn0` (`r round(hitp0, 2)` %)

Custom identifiers found after subsetting: n=`r hitn1` (`r round(hitp1, 2)` %) 

Figure shows how document length and number of hits are related:

```{r normalization, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE, fig.width=7, fig.height=7, out.width="150px"}
p <- ggplot(custom.ids, aes(x = length, y = freq.normalized)) + 
       geom_point() + scale_x_log10() + scale_y_log10() +
       xlab("Document length") + ylab("Hits per unit length (x1000)")
print(p)       
```

### Timeline for title count

```{r titlecount, echo=FALSE, message=FALSE, warning=FALSE, echo=FALSE, cache=FALSE, fig.width=15, fig.height=7}

# TODO could make custom function to show relative fraction compared to the complete database
# now done manually here.

# Stats for our custom list
myfield <- "titlecount"
res0 <- timeline(df0, field = myfield, nmin = 0, mode = "absolute") 
fig0 <- res0$plot
tab0 <- res0$table
tab0$group <- rep("Custom", nrow(tab0))

# Stats in the complete data set
# Limit the analysis on the same time window
tab <- timeline(df.preprocessed, field = myfield, nmin = 0, mode = "absolute")$table
tab$group <- rep("ESTC", nrow(tab))
tab <- subset(tab, publication_decade >= min(tab0$publication_decade) &
                   publication_decade <= max(tab0$publication_decade))

df <- bind_rows(tab, tab0)
df$group <- factor(df$group)
df <- df %>% select(publication_decade, group, absolute) %>% 
             spread(key = "group", value = "absolute", fill = 0) 
df <- df %>%mutate(fraction = 100 * Custom/ESTC)

p <- ggplot(df, aes(y = fraction, x = publication_decade)) + 
       geom_bar(stat = "identity") + 
       ylab("Fraction of total documents (%)")  + 
       xlab("Publication decade") +
	     ggtitle("Relative to all documents") 

p1 <- fig0 + ylab("Title count (n)") + ggtitle("Absolute")
p2 <- p
grid.arrange(p1, p2, nrow = 1)
```




### Timeline for paper consumption

```{r paper, echo=FALSE, message=FALSE, warning=FALSE, echo=FALSE, cache=FALSE, fig.width=15, fig.height=7}
# Stats for our custom list
myfield <- "paper"
res0 <- timeline(df0, field = myfield, nmin = 0, mode = "absolute") 
fig0 <- res0$plot
tab0 <- res0$table
tab0$group <- rep("Custom", nrow(tab0))

# Stats in the complete data set
# Limit the analysis on the same time window
tab <- timeline(df.preprocessed, field = myfield, nmin = 0, mode = "absolute")$table
tab$group <- rep("ESTC", nrow(tab))
tab <- subset(tab, publication_decade >= min(tab0$publication_decade) &
                   publication_decade <= max(tab0$publication_decade))

df <- bind_rows(tab, tab0)
df$group <- factor(df$group)
df <- df %>% select(publication_decade, group, absolute) %>% 
             spread(key = "group", value = "absolute", fill = 0) 
df <- df %>%mutate(fraction = 100 * Custom/ESTC)

p <- ggplot(df, aes(y = fraction, x = publication_decade)) + 
       geom_bar(stat = "identity") + 
       ylab("Fraction of total documents (%)")  + 
       xlab("Publication decade") +
	     ggtitle("Relative to all documents") 

p1 <- fig0 + ylab("Paper (sheets)") + ggtitle("Absolute")
p2 <- p
grid.arrange(p1, p2, nrow = 1)
```

### Paper consumption: books vs. pamphlets

```{r bookvspamphlets, echo=FALSE, message=FALSE, warning=FALSE, echo=FALSE, fig.width=10, fig.height=7}
df <- df0
df$type <- rep(NA, nrow(df))
df$type[df$pagecount > 32] <- "book"
df$type[df$pagecount <= 32] <- "pamphlet"
df$type <- factor(df$type)

df2 <- df %>% group_by(publication_year, type) %>%
              summarize(paper = sum(paper, na.rm = TRUE), n = n()) %>%
	      filter(!is.na(type))
p <- ggplot(df2, aes(x = publication_year, y = paper, group = type, color = type))
p <- p + geom_point() + scale_y_log10() 
p <- p + geom_smooth(method = "loess")
p <- p + xlab("Year")
p <- p + ylab("Paper (sheets)")
print(p)
```


### Top authors

The top authors can be defined by title count (regardless of number of hits in each title; left) or by the total sum of query hits across all documents (middle).

```{r topauthors, echo=FALSE, message=FALSE, warning=FALSE, fig.width=12, fig.height=5}
df <- df0
p <- NULL
p1 <- top_plot(df, "author", ntop) +
     		  ggtitle("Title count") +
		  ylab("Title count (n)") 

# Use unnormalized frequency for now
field <- "author"
df$hits <- custom.ids[match(df$id, custom.ids$id), "freq"]
df$names <- df[[field]]
dfs <- df %>% group_by(names) %>%
              filter(!is.na(names)) %>% 
              summarise(count = sum(hits, na.rm = T)) %>%
	      arrange(desc(count)) %>%
	      head(ntop) 

  dfs$names <- droplevels(factor(dfs$names, levels = rev(dfs$names)))
  theme_set(theme_bw(15))  
  p <- ggplot(dfs, aes(x = names, y = count))
  p <- p + geom_bar(stat = "identity")
  p <- p + coord_flip()
  p <- p + ylab("Term occurrences (n)") + xlab("")
  p <- p + ggtitle("Query hits")
  p2 <- p

# Timeline for hits
#res <- timeline(df, field = "hits", nmin = 0, mode = "absolute") 
#p3 <- res$plot

grid.arrange(p1, p2, nrow = 1)
```


### Title count timeline for top 10 authors

```{r topauthorstimeline, fig.height=4, fig.width=10, echo=FALSE}
df <- df0
theme_set(theme_bw(20))
top.authors <- names(top(df, field = "author", n = 10))
dfs <- df %>% filter(author %in% top.authors) %>%
     	 group_by(author, publication_decade) %>%
     	 tally() %>%
     	 arrange(publication_decade)
v <- seq(min(dfs$publication_decade), max(dfs$publication_decade), 20)
p <- ggplot(dfs, aes(x = publication_decade, y = n, fill = author)) +
       geom_bar(stat = "identity", position = "stack", color = "black") +
       xlab("Publication decade") +
       ylab("Title count (n)") +
       scale_fill_grey() +
       scale_x_continuous(breaks = v, labels = v) +
       guides(fill = guide_legend("Author", reverse = TRUE)) 
       #ggtitle("Title count timeline for the top authors")
print(p)
```



### Top places

The top places can be defined by title count (regardless of number of hits in each title; left) or by the total sum of query hits across all documents (middle).

```{r topplaces, echo=FALSE, message=FALSE, warning=FALSE, fig.width=12, fig.height=5}
df <- df0
p <- NULL
v <- 10^(1:max(na.omit(round(log10(max(table(df$publication_place)))))))
p1 <- top_plot(df, "publication_place", ntop) +
     		  ggtitle(paste("Title count")) +
		  ylab("Title count (n)") +
  		  scale_y_log10(breaks = v, labels = v)    		  

# Use unnormalized frequency for now
field <- "publication_place"
df$hits <- custom.ids[match(df$id, custom.ids$id), "freq"]
df$names <- df[[field]]
dfs <- df %>% group_by(names) %>%
              filter(!is.na(names)) %>% 
              summarise(count = sum(hits, na.rm = T)) %>%
	      arrange(desc(count)) %>%
	      head(ntop) 

  dfs$names <- droplevels(factor(dfs$names, levels = rev(dfs$names)))
  theme_set(theme_bw(15))  
  p <- ggplot(dfs, aes(x = names, y = count))
  p <- p + geom_bar(stat = "identity")
  p <- p + coord_flip()
  v <- 10^(1:max(na.omit(round(log10(max(dfs$count))))))
  p <- p + scale_y_log10(breaks = v, labels = v)
  #p <- p + scale_y_log10(breaks = v, labels = v)    
  p <- p + ylab("Term occurrences (n)") + xlab("")
  p <- p + ggtitle("Query hits")
  p2 <- p

# Timeline for hits
# res <- timeline(df, field = "hits", nmin = 0, mode = "absolute") 
# p3 <- res$plot

grid.arrange(p1, p2, nrow = 1)
```




### Top titles

```{r toptitles-init, echo=FALSE, message=FALSE, warning=FALSE}
nchar <- 40
```

The title length is here limited; up to `r nchar` first characters are shown:

```{r toptitles, echo=FALSE, message=FALSE, warning=FALSE, fig.width=11, fig.height=5}
df <- df0
# Limit title length
df$title <- substr(as.character(df$title), 1, nchar)
p <- top_plot(df, "title", ntop = ntop) +
  ggtitle(paste("Top titles")) +
  scale_y_log10() +
  ylab("Title count (n)")
print(p)
```








